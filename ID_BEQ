//Static int ID_WorkCycles = 0;      needs to be in main() to be exported to main at the end of sim                  
void ID()
{
	Static int BeqTimer = 0;                                              //holds a timer for BEQ hazard avoidance
	
	if(IF_ID_latch.rs != ID_EX_latch.rd &&                                //This looks complicated but It just checks
	   IF_ID_latch.rt != ID_EX_latch.rd &&                                //that I'm not about to read a reg that is a 
	   IF_ID_latch.rs != EX_MEM_latch.rd &&                               //destination reg for a instruction further 
	   IF_ID_latch.rt != EX_MEM_latch.rd &&                               //down the pipe
	   (IF_ID_latch.rs != MEM_WB_latch.rd && MEM_WB_Flag != 1) &&
	   (IF_ID_latch.rt != EX_MEM_latch.rd && MEM_WB_Flag != 1))           //If Flag=0 then Write has happened and r/w can happen same cycle
	{
		if(IF_ID_latch.inst_op == BEQ && ID_EX_latch.inst_op != BEQ && ID_EX_Flag == 0 && IF_ID_Flag == 1)  //If Its a branch, yet to move forward, EX is ready, IF fetched
		{
			++ID_WorkCycles;                                                    //1 cycle of work
			ID_EX_Latch = IF_ID_Latch;                                       //Copy to ex recieve latch
			ID_EX_Latch.rs = Registers[rs]; 
			ID_EX_Latch.rt = Registers[rt];                                  //fill struct with reg data for ex
		        ID_EX_Flag = 1;                                                  //Tell EX its a go on the next cycle
			BeqTimer = n + 1;                                                //Cycles EX reqires to resolve BEQ, could be off - 1 or -2                                    
		}
		else if (BeqTimer != 0)   //Its a BEQ that has been moved forward but IF is/was waiting on proper PC
		{
			if(BeqTimer != 1)
			{
				--BeqTimer; 	                                  //keep counting down
			}
			else
			{
				IF_ID_Flag = 0;    //Program counter is set, so IF can fetch
                        	--BeqTimer;        //Set back to 0 
			}
		}
		else if(IF_ID_latch.inst_op == ADD && ID_EX_Flag == 0 && IF_ID_Flag == 1) //If its an add and Ex is ready and IF fetched last cycle
		{
			++ID_WorkCycles;                               //Doing work
			ID_EX_latch = IF_ID_latch;                     //Copy it forward
			ID_EX_latch.rs = Registers[rs];                //replace register #s with the data inside them
			ID_EX_latch.rt = Registers[rt];
			ID_EX_Flag = 1;                                //Tell EX that next cycle is greenlight
			IF_ID_Flag = 0;                                //Tell IF the latch is clear to be overwritten
		}
		else if(IF_ID_latch.inst_op == ADDI && ID_EX_Flag == 0 && IF_ID_Flag == 1)
		{
			++ID_WorkCycles;                               //Record work done
			ID_EX_latch = IF_ID_latch;                     //Copy it forward
			ID_EX_latch.rs = Registers[rs];                //Only the rs reg, !!!rt is the destination reg for addi!!!
			ID_EX_Flag = 1;                                //Tell EX that next cycle it can start
			IF_ID_Flag = 0;                                //Tell IF the latch is clear to be overwritten
		}
		else if(IF_ID_latch.inst_op == SUB && ID_EX_Flag == 0 && IF_ID_Flag == 1)
		{
			++ID_WorkCycles;                               //Doing work
			ID_EX_latch = IF_ID_latch;                     //Copy it forward
			ID_EX_latch.rs = Registers[rs];                //replace register #s with the data inside them
			ID_EX_latch.rt = Registers[rt];
			ID_EX_Flag = 1;                                //Tell EX that next cycle is greenlight
			IF_ID_Flag = 0;                                //Tell IF the latch is clear to be overwritten
		}
		else if(IF_ID_latch.inst_op == LW && ID_EX_Flag == 0 && IF_ID_Flag == 1)
		{
			++ID_WorkCycles;                               //Record work done
			ID_EX_latch = IF_ID_latch;                     //Copy it forward
			ID_EX_latch.rs = Registers[rs];                //Only the rs reg, used with immediate by EX and MEM 
			ID_EX_latch.rd = ID_EX_latch.rt			//rt is reg destination used by WB so to simplify RAW detection and WB I moved it into rd
			ID_EX_Flag = 1;                                //Tell EX that next cycle it can start
			IF_ID_Flag = 0;                                //Tell IF the latch is clear to be overwritten
		}
		else if(IF_ID_latch.inst_op == SW && ID_EX_Flag == 0 && IF_ID_Flag == 1)
		{
			++ID_WorkCycles;                               //Record work done
			ID_EX_latch = IF_ID_latch;                     //Copy it forward
			ID_EX_latch.rs = Registers[rs];                //rs is used by EX along with immediate to get memory address
			ID_EX_latch.rt = Registers[rt];                //rt is use by MEM as it is the data to be written into memory
			ID_EX_Flag = 1;                                //Tell EX that next cycle it can start
			IF_ID_Flag = 0;                                //Tell IF the latch is clear to be overwritten
		}
		else if(IF_ID_latch.inst_op == MUL && ID_EX_Flag == 0 && IF_ID_Flag == 1)
		{
			++ID_WorkCycles;                               //Doing work
			ID_EX_latch = IF_ID_latch;                     //Copy it forward
			ID_EX_latch.rs = Registers[rs];                //replace register #s with the data inside them
			ID_EX_latch.rt = Registers[rt];
			ID_EX_Flag = 1;                                //Tell EX that next cycle it can start
			IF_ID_Flag = 0;                                //Tell IF the latch is clear to be overwritten
		}
		//If none of the above conditions are met other stages are busy or not a valid opcode (wait)
	}
	//If theres a RAW hazard do nothing (wait)
