//Static int ID_WorkCycles = 0;      needs to be in main() to be exported to main at the end of sim                  
void ID()
{
	Static int BeqTimer = 0;                                              //holds a timer for BEQ hazard avoidance 
	
	if(IF_ID_latch.op == LW || IF_ID_latch.op == ADDI)
	{                                                                      //This doesn't change any reg data, just holds reg # 
		IF_ID_latch.rd = IF_ID_latch.rt;                               //makes RAW check simpler and rd isn't being used anyways, exists in both fields
	}                                                                     //this will redunantly copy if pipe is stalled but won't hurt anything
	                                                                      
	
	if((IF_ID_latch.rs != ID_EX_latch.rd || ID_EX_Flag == 0) &&           //This looks complicated but It just checks
	   (IF_ID_latch.rt != ID_EX_latch.rd || ID_EX_Flag == 0) &&          //that I'm not about to read a reg that is a 
	   (IF_ID_latch.rs != EX_MEM_latch.rd || EX_MEM_Flag == 0) &&        //destination reg for a instruction further 
	   (IF_ID_latch.rt != EX_MEM_latch.rd || EX_MEM_Flag == 0) &&        //down the pipe, IF A FLAG == 0 the assoicated latch is stale and not "in the pipe"
	   (IF_ID_latch.rs != MEM_WB_latch.rd || MEM_WB_Flag == 0) &&         //rd must be set to 32 <= rd <= -1 in previous latch after its copied forward out of EX and MEM
	   (IF_ID_latch.rt != MEM_ WB_latch.rd || MEM_WB_Flag == 0))           //If Flag=0 then Write has happened and r/w can happen same cycle
	{
		if(IF_ID_latch.op == BEQ && ID_EX_latch.op != BEQ && ID_EX_Flag == 0 && IF_ID_Flag == 1) //If Its a branch, yet to move forward, EX is ready,IF fetched
		{
			++ID_WorkCycles;                                                 //1 cycle of work
			ID_EX_Latch = IF_ID_Latch;                                       //Copy to ex recieve latch
			ID_EX_Latch.rs = Registers[rs]; 
			ID_EX_Latch.rt = Registers[rt];                                  //fill struct with reg data for ex
		        ID_EX_Flag = 1;                                                  //Tell EX its a go on the next cycle
			BeqTimer = n + 1;                                                //Cycles EX reqires to resolve BEQ, could be off - 1 or -2                                    
		}
		else if (BeqTimer != 0)   //Its a BEQ that has been moved forward but IF is/was waiting on proper PC
		{
			if(BeqTimer != 1)
			{
				--BeqTimer; 	                                  //keep counting down
			}
			else
			{
				IF_ID_Flag = 0;                //Program counter is set, so IF can fetch
                        	--BeqTimer;                    //Set back to 0 
				ID_EX_latch.op = DEADBEQ; //Needed incase of 2+ BEQ in a row, but since BEQ terminates in EX it won't go anywhere
			}
		}
		else if(IF_ID_latch.op == ADD && ID_EX_Flag == 0 && IF_ID_Flag == 1) //If its an add and Ex is ready and IF fetched last cycle
		{
			++ID_WorkCycles;                               //Doing work
			ID_EX_latch = IF_ID_latch;                     //Copy it forward
			ID_EX_latch.rs = Registers[rs];                //replace register #s with the data inside them
			ID_EX_latch.rt = Registers[rt];
			ID_EX_Flag = 1;                                //Tell EX that next cycle is greenlight
			IF_ID_Flag = 0;                                //Tell IF the latch is clear to be overwritten
		}
		else if(IF_ID_latch.op == ADDI && ID_EX_Flag == 0 && IF_ID_Flag == 1)
		{
			++ID_WorkCycles;                               //Record work done
			ID_EX_latch = IF_ID_latch;                     //Copy it forward
			ID_EX_latch.rs = Registers[rs];                //Only the rs reg, both rd and rt are the destination reg for addi
			ID_EX_Flag = 1;                                //Tell EX that next cycle it can start
			IF_ID_Flag = 0;                                //Tell IF the latch is clear to be overwritten
		}
		else if(IF_ID_latch.op == SUB && ID_EX_Flag == 0 && IF_ID_Flag == 1)
		{
			++ID_WorkCycles;                               //Doing work
			ID_EX_latch = IF_ID_latch;                     //Copy it forward
			ID_EX_latch.rs = Registers[rs];                //replace register #s with the data inside them
			ID_EX_latch.rt = Registers[rt];
			ID_EX_Flag = 1;                                //Tell EX that next cycle is greenlight
			IF_ID_Flag = 0;                                //Tell IF the latch is clear to be overwritten
		}
		else if(IF_ID_latch.op == LW && ID_EX_Flag == 0 && IF_ID_Flag == 1)
		{
			++ID_WorkCycles;                               //Record work done
			ID_EX_latch = IF_ID_latch;                     //Copy it forward
			ID_EX_latch.rs = Registers[rs];                //Only the rs reg, used with immediate by EX and MEM 
			                                               //use rt or rd for destination
			ID_EX_Flag = 1;                                //Tell EX that next cycle it can start
			IF_ID_Flag = 0;                                //Tell IF the latch is clear to be overwritten
		}
		else if(IF_ID_latch.op == SW && ID_EX_Flag == 0 && IF_ID_Flag == 1)
		{
			++ID_WorkCycles;                               //Record work done
			ID_EX_latch = IF_ID_latch;                     //Copy it forward
			ID_EX_latch.rs = Registers[rs];                //rs is used by EX along with immediate to get memory address
			ID_EX_latch.rt = Registers[rt];                //rt is use by MEM as it is the data to be written into memory
			ID_EX_Flag = 1;                                //Tell EX that next cycle it can start
			IF_ID_Flag = 0;                                //Tell IF the latch is clear to be overwritten
		}
		else if(IF_ID_latch.op == MUL && ID_EX_Flag == 0 && IF_ID_Flag == 1)
		{
			++ID_WorkCycles;                               //Doing work
			ID_EX_latch = IF_ID_latch;                     //Copy it forward
			ID_EX_latch.rs = Registers[rs];                //replace register #s with the data inside them
			ID_EX_latch.rt = Registers[rt];
			ID_EX_Flag = 1;                                //Tell EX that next cycle it can start
			IF_ID_Flag = 0;                                //Tell IF the latch is clear to be overwritten
		}
		else if(IF_ID_latch.op == HALT && ID_EX_Flag == 0 && IF_ID_Flag == 1)
		{
			ID_EX_latch = IF_ID_latch;                     //Copy it forward
			ID_EX_Flag = 1;                                //Tell EX that next cycle it can recieve
		}
		//If none of the above conditions are met other stages are busy or not a valid opcode (wait)
	}
	//If theres a RAW hazard do nothing (wait)
	
}
